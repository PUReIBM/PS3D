      subroutine rann2(x,jf,jl,kf,kl,jdim)
c
c  routine to generate vectors of independent random numbers with
c  a user-specified distribution.
c
c  **  set up for the standardized normal distribution  **
c  **  modified 8/10/88 by s.b. pope to force standardization
c       if there are 5 or more trials  **
c
c  arguments:
c    x - two-dimensional array in which the random numbers are
c    returned.  x(j,k) is the k th component of the random vector
c    on the j th trial.  the vector length is nk=kl+1-kf, with kf
c    and kl being the first and last values of k. there are nj=jl+1-jf
c    trials , with jf and jl being the first and last trial numbers.
c    x has dimensions x(jdim,kdim), where jdim .ge. jl, kdim .ge. kl .
c
c  notes:
c    user must supply functions - see below.
c    for one-dimensional arrays, jf=jl=1.
c    other routines called - ranu2, erff
c
c  method:
c    the random variable x has the specified distribution function
c    fdist(x) and the density function fdens(x).  if y is a uniformly
c    distributed random variable (0. lt. y .lt. 1.), then x
c    satisfying the implicit equation  y=fdist(x)  is the required
c    random number.  on the first call, a table of x values is set
c    up corresponding to equally spaced y values.  then the
c    subroutine ranu2 is called to obtain random values of y, and
c    the corresponding x value is obtained from the table by
c    linear interpolation.  if the inverse of the distribution
c    function, finv, is known, then the table can be set up by
c    x = finv( fdist(x) ) = finv(y) .    in this case the user
c    must supply the fortran statement function finv(y).
c    if the inverse is not known then the distribution function
c    fdist(x) and the pdf fdens(x) must be supplied as statement
c    functions.  an iterative procedure is then used to solve the
c    implicit equation  y = fdist(x) .
c
c  user specifications:
c    ntab      - number of table entries.
c    mode = 1  - inverse function finv is supplied,
c         = 2  - fdist and fdens are supplied.
c    xmin,xmax - minimum and maximum values of x. (even if x is
c                unbounded, finite values must be specified)
c    finv(y)   - inverse of fdist(x) - mode = 1 only.
c    fdist(x)  - distribution function. it must be strictly increasing
c                and be between zero and one - mode = 2 only.
c    fdens(x)  - pdf (derivative of fdist(x)).  it must be strictly
c                positive everywhere - mode = 2 only.
c
c  comments:
c    this routine is designed to be computationally efficient,
c    with moderate accuracy, for the generation of a large number
c    of random numbers.  it is not extremely accurate and is
c    inefficient for generating only a few numbers.
c
c  current version:
c    set up for mode = 2.
c    fdens here is symmetric - the table set-up exploits this symmetry,
c    ensuring no bias in the odd moments (all odd moments identically 0)
c    ntab must be odd to ensure symmetry.
c    a singe parameter (p1) asymptotic approximation replaces linear
c    interpolation in the end intervals. the table values at the 2nd, 3r
c    ntab-1, and ntab-2 points are given by parameters p2 and p3 (tab(2)
c    -tab(ntab-1) = p2, tab(3) = -tab(ntab-2) = p3);  p1 is then chosen
c    match values from the asymptotic function and the linear interpolat
c    at tab(2) and tab(ntab-1).
c    parameters p2 and p3 are chosen to give proper variance 1.0 and
c    proper flatness 3.0 from an exact integral over the appoximated
c    distribution function; this is implemented only for mode = 2.
c    p2 and p3 are optimized for ntab = 101, 201, 301; a parabola is
c    fit thru these three points. this gives the proper variance and
c    flatness to within 1% for 89 <= ntab <= 351, (ntab odd).
c    6th and 8th moments are within approximately 5% of their proper
c    values (15.0 and 105.0 respectively) over this range.
c
c    the largest/smallest value of x is given in absolute value by
c    xmax = sqrt(-ln(2*pi*p1*p1*xp*xp)) where xp is the closest
c    number to 1.0/0.0 that can be generated by ranu2.  for xp = 1.e-7
c    (typical value for 32 bit single precision) xmax is approximately
c    5.3.  xp = 1.e-7 is assumed here in the computation of xmax;
c    xmax and xmin are not critical - affect only starting point for
c    table set-up.
c
      parameter (ntab=201)
      dimension tab(ntab),dtab(ntab),x(jdim,kl)
      save azer,tab,dtab,pi,p1,ntabm,init
c
      fdens(xx) = rtpii*exp(-0.5*xx*xx)
      fdist(xx) = 0.5*(1.+erff(rti*xx))
c
c  finv not used
c
      finv(yy) = 0.
c
      data mode /2/
      data pi,rtpii,rti /3.1415927,0.3989423,0.7071068/
      data azer /1.e-20/
      data init /0/
c
c  need ntab odd to ensure symmetry
c
      if( mod(ntab,2) .eq. 0 ) then
       write(6,910) ntab
       stop
       end if
c
c  compute table on first call
c
      if( init .eq. 0 ) go to 500
c
c  fill array with uniformly distributed random numbers
c
50    call ranu2(x,jf,jl,kf,kl,jdim)
c
c  linearly interpolate from table;
c  use asymptotic function for n=1 or n=ntabm
c
      do 100 j=jf,jl
        do 100 k=kf,kl
          y = x(j,k)*ntabm+1
          i = y
          if( i .eq. 1 ) then
           y1 = x(j,k)
           y1 = 2.*pi*p1*p1*y1*y1
           if( y1 .le. 0. ) then
            write(6,*) 'rann2: y1=',y1
            y1 = azer
            end if
           y1 = -alog(y1)
           x(j,k) = -sqrt(y1)
           go to 100
           end if
          if( i .eq. ntabm ) then
           y1 = 1.-x(j,k)
           y1 = 2.*pi*p1*p1*y1*y1
           y1 = -alog(y1)
           x(j,k) = sqrt(y1)
           go to 100
           end if
          y = y-i
          x(j,k) = tab(i)+y*dtab(i)
100       continue
c
c  perform standardization
c
	nsamp = jl + 1 -jf
	if( nsamp .ge. 5 ) then
	   do 200 k = kf, kl
200	   call ranstd( x(jf,k) , nsamp )
	endif
c
	return
c
c  set up table
c
500   init   = 1
      ntabm  = ntab-1
      ntabmm = ntabm-1
      ntsq   = ntab*ntab
      dy     = 1./float(ntabm)
      p3     = ntsq*5.800e-6 - ntab*4.35160e-3 - 1.7006542
      p2     = ntsq*6.035e-6 - ntab*4.46257e-3 - 1.8738435
      p1     = ntabm*exp(-p2*p2/2.)/sqrt(2.*pi)
      xmin   = 2.*pi*p1*p1*1.e-14
      xmin   = -alog(xmin)
      xmin   = -sqrt(xmin)
      xmax   = -xmin
      tab(1) = xmin
      tab(2) = p2
      tab(3) = p3
      tab(ntab)   = xmax
      tab(ntabm)  = -p2
      tab(ntabmm) = -p3
c
c  set up table from inverse of fdist
c
      if( mode .eq. 2 ) go to 600
      y = 0.
      do 510 i=2,ntabm
        y = y+dy
510     tab(i) = finv(y)
      go to 700
c
c  set up table by solving y=fdist(x).  combination of bisection and
c  newton's method.
c
600   y  = 2.*dy
      xx = tab(3)+dy*(xmax-xmin)
      ntabh = ntab/2
      do 610 i=4,ntabh
        y = y+dy
c
c set max. and min. xx and initial guess
c
        xxmin = tab(i-1)
        xxmax = xmax
c
c  iterate
c
        do 620 iter=1,50
          yy = fdist(xx)
          err = yy-y
          if( abs(err) .lt. 1.e-6 ) go to 610
          if( err .gt. 0. ) xxmax=xx
          if( err .lt. 0. ) xxmin=xx
c
c  newton's method
c
          xx = xx+err/amax1(fdens(xx),1.e-10)
c
c if new value exceeds known bounds, use bisection
c
          if( xx .le. xxmin .or. xx .ge. xxmax ) xx=0.5*(xxmin+xxmax)
620       continue
c
        write(6,900) y,err,xx,xxmin,xxmax
c       stop
c
c  convergence - enter value in table
c
610     tab(i) = xx
c
c  symmetric distribution - fill in other half
c
      do 630 i=1,ntabh
        i1 = ntab-i+1
630     tab(i1) = -tab(i)
      tab(ntabh+1) = 0.
c
c  set dtab
c
700   do 710 i=1,ntabm
710     dtab(i) = tab(i+1)-tab(i)
c
c  end of table set up
c
      go to 50
c
900   format(1x,'convergence failure in rann2:',1p,5e13.5)
910   format(1x,'error in rann2: ntab =',i4,'; ntab must be odd.')
c
      end
      function erff(x)
c
c  from abramowitz 7.1.26
c
      save
      data p,a1,a2,a3,a4,a5/.3275911,.254829592,-.284496736,
     *  1.421413741,-1.453152027,1.061405429/
c
      t=1./(1.+p*abs(x))
c
      q=t*(a1+t*(a2+t*(a3+t*(a4+t*a5))))
c
      erff=1.-q*exp(-x*x)
      if( x .lt. 0. ) erff=-erff
c
      return
      end
